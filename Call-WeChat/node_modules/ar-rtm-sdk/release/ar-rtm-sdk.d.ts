declare type addListenerCallbcak<T> = (...args: any[]) => T;

declare namespace ArRTM {
    const BUILD: string;
    const ConnectionChangeReason: RtmStatusCode.ConnectionChangeReason;
    const ConnectionState: RtmStatusCode.ConnectionState;
    const END_CALL_PREFIX: string;
    const LOG_FILTER_ERROR: LogFilterType;
    const LOG_FILTER_INFO: LogFilterType;
    const LOG_FILTER_OFF: LogFilterType;
    const LOG_FILTER_WARNING: LogFilterType;
    const LocalInvitationState: RtmStatusCode.LocalInvitationState;
    const MessageType: RtmStatusCode.MessageType;
    const PeerOnlineState: RtmStatusCode.PeerOnlineState;
    const PeerSubscriptionOption: RtmStatusCode.PeerSubscriptionOption;
    const RemoteInvitationFailureReason: RtmStatusCode.RemoteInvitationFailureReason;
    const LocalInvitationFailureReason: RtmStatusCode.LocalInvitationFailureReason;
    const RemoteInvitationState: RtmStatusCode.RemoteInvitationState;
    const VERSION: string;
    function createInstance(appId: string, params?: RtmParameters): IRtmClient;
}
export { ArRTM }
export default ArRTM;

export declare interface AttributesMap {
    [key: string]: string;
}

export declare interface ChannelAttributeOptions {
    enableNotificationToChannelMembers?: undefined | false | true;
}

export declare interface ChannelAttributeProperties {
    lastUpdateTs: number;
    lastUpdateUserId: string;
    value: string;
}

export declare interface ChannelAttributes {
    [key: string]: ChannelAttributeProperties;
}

export declare interface ChannelMemberCountResult {
    [channelId: string]: number;
}

declare class EventEmitter<T> {
    private _events;
    private addListener;
    constructor();
    getListeners(event: string): unknown[];
    on(event: string, callback: addListenerCallbcak<void>): void;
    once(event: string, callback: addListenerCallbcak<void>): void;
    off(event: string, callback: addListenerCallbcak<void>): void;
    removeAllListeners(event?: string): void;
    emit(event: string, ...args: any[]): void;
    private _indexOfListener;
}

export declare interface IRtmChannel {
    getMembers(): Promise<string[]>;
    join(): Promise<void>;
    leave(): Promise<void>;
    sendMessage(message: RtmMessage, messageOptions?: SendMessageOptions): Promise<void>;
    on(event: "AttributesUpdated", listener: (attributes: ChannelAttributes) => void): void;
    on(event: "ChannelMessage", listener: (message: RtmMessage, memberId: string, messageProps: ReceivedMessageProperties) => void): void;
    on(event: "MemberCountUpdated", listener: (memberCount: number) => void): void;
    on(event: "MemberJoined", listener: (memberId: string) => void): void;
    on(event: "MemberLeft", listener: (memberId: string) => void): void;
}

export declare interface IRtmClient {
    addOrUpdateChannelAttributes(channelId: string, attributes: AttributesMap, options?: ChannelAttributeOptions): Promise<void>;
    addOrUpdateLocalUserAttributes(attributes: AttributesMap): Promise<void>;
    clearChannelAttributes(channelId: string, options?: ChannelAttributeOptions): Promise<void>;
    clearLocalUserAttributes(): Promise<void>;
    createChannel(channelId: string): IRtmChannel;
    createLocalInvitation(calleeId: string): LocalInvitation;
    deleteChannelAttributesByKeys(channelId: string, attributeKeys: string[], options?: ChannelAttributeOptions): Promise<void>;
    deleteLocalUserAttributesByKeys(attributeKeys: string[]): Promise<void>;
    getChannelAttributes(channelId: string): Promise<ChannelAttributes>;
    getChannelAttributesByKeys(channelId: string, keys: string[]): Promise<ChannelAttributes>;
    getChannelMemberCount(channelIds: string[]): Promise<ChannelMemberCountResult>;
    getUserAttributes(userId: string): Promise<AttributesMap>;
    getUserAttributesByKeys(userId: string, attributeKeys: string[]): Promise<AttributesMap>;
    login(options: {
        token?: undefined | string;
        uid: string;
    }): Promise<void>;
    logout(): Promise<void>;
    queryPeersBySubscriptionOption(option: RtmStatusCode.PeerSubscriptionOption): Promise<string[]>;
    queryPeersOnlineStatus(peerIds: string[]): Promise<PeersOnlineStatusResult>;
    renewToken(token: string): Promise<void>;
    sendMessageToPeer(message: RtmMessage, peerId: string, options?: SendMessageOptions): Promise<PeerMessageSendResult>;
    setChannelAttributes(channelId: string, attributes: AttributesMap, options?: ChannelAttributeOptions): Promise<void>;
    setLocalUserAttributes(attributes: AttributesMap): Promise<void>;
    setParameters(params: RtmParameters): void;
    subscribePeersOnlineStatus(peerIds: string[]): Promise<void>;
    unsubscribePeersOnlineStatus(peerIds: string[]): Promise<void>;
    on(event: "ConnectionStateChanged", listener: (newState: RtmStatusCode.ConnectionState, reason: RtmStatusCode.ConnectionChangeReason) => void): void;
    on(event: "MessageFromPeer", listener: (message: RtmMessage, peerId: string, messageProps: ReceivedMessageProperties) => void): void;
    on(event: "RemoteInvitationReceived", listener: (remoteInvitation: RemoteInvitation) => void): void;
    on(event: "PeersOnlineStatusChanged", listener: (peerOnlineStatus: PeersOnlineStatusMap) => void): void;
    on(event: "TokenExpired", listener: () => void): void;
}

declare class LocalInvitation extends EventEmitter<RtmEvents.LocalInvitationEvents> {
    private _callId;
    readonly calleeId: string;
    client: any;
    content: string;
    state: keyof typeof RtmStatusCode.LocalInvitationState;
    readonly response: string;
    constructor(client: any, callId: string, calleeId: string);
    cancel(): void;
    send(): void;
}

declare type LogFilterType = string;

declare type LogFilterType_2 = string;

export declare interface PeerMessageSendResult {
    hasPeerReceived: boolean;
}

export declare interface PeersOnlineStatusMap {
    [peerId: string]: RtmStatusCode.PeerOnlineState;
}

export declare interface PeersOnlineStatusResult {
    [peerId: string]: boolean;
}

export declare interface ReceivedMessageProperties {
    isHistoricalMessage: boolean;
    isOfflineMessage: boolean;
    serverReceivedTs: number;
}

declare class RemoteInvitation extends EventEmitter<RtmEvents.RemoteInvitationEvents> {
    client: any;
    private _callId;
    readonly callerId: string;
    readonly content: string;
    response: string;
    state: keyof typeof RtmStatusCode.RemoteInvitationState;
    constructor(callId: string, callerId: string, content: string);
    accept(): void;
    refuse(): void;
}

export declare namespace RtmErrorCode {
    export enum AttributeOperationError {
        ATTRIBUTE_OPERATION_ERR_FAILURE = 2,
        ATTRIBUTE_OPERATION_ERR_INVALID_ARGUMENT = 3,
        ATTRIBUTE_OPERATION_ERR_SIZE_OVERFLOW = 4,
        ATTRIBUTE_OPERATION_ERR_TOO_OFTEN = 5,
        ATTRIBUTE_OPERATION_ERR_USER_NOT_FOUND = 6,
        ATTRIBUTE_OPERATION_ERR_TIMEOUT = 7,
        ATTRIBUTE_OPERATION_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum ChannelMessageError {
        CHANNEL_MESSAGE_ERR_FAILURE = 1,
        CHANNEL_MESSAGE_ERR_TIMEOUT = 2,
        CHANNEL_MESSAGE_ERR_TOO_OFTEN = 3,
        CHANNEL_MESSAGE_ERR_INVALID_MESSAGE = 4,
        CHANNEL_MESSAGE_ERR_NOT_IN_CHANNEL = 5,
        CHANNEL_MESSAGE_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum CreateChannelError {
        CREATE_CHANNEL_ERR_INVALID_ARGUMENT = 1
    }
    export enum CreateInstanceError {
        CREATE_INSTANCE_ERR_INVALID_ARGUMENT = 1
    }
    export enum GetChannelMemberCountErrCode {
        GET_CHANNEL_MEMBER_COUNT_ERR_FAILURE = 1,
        GET_CHANNEL_MEMBER_COUNT_ERR_INVALID_ARGUMENT = 2,
        GET_CHANNEL_MEMBER_COUNT_ERR_TOO_OFTEN = 3,
        GET_CHANNEL_MEMBER_COUNT_ERR_TIMEOUT = 4,
        GET_CHANNEL_MEMBER_COUNT_ERR_EXCEED_LIMIT = 5,
        GET_CHANNEL_MEMBER_COUNT_ERR_NOT_INITIALIZED = 101,
        GET_CHANNEL_MEMBER_COUNT_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum GetMembersError {
        GET_MEMBERS_ERR_FAILURE = 1,
        GET_MEMBERS_ERR_REJECTED = 2,
        GET_MEMBERS_ERR_TIMEOUT = 3,
        GET_MEMBERS_ERR_TOO_OFTEN = 4,
        GET_MEMBERS_ERR_NOT_IN_CHANNEL = 5,
        GET_MEMBERS_ERR_USER_NOT_LOGGED_IN = 6
    }
    export enum InvitationApiCallError {
        INVITATION_API_CALL_ERR_INVALID_ARGUMENT = 1,
        INVITATION_API_CALL_ERR_NOT_STARTED = 2,
        INVITATION_API_CALL_ERR_ALREADY_END = 3,
        INVITATION_API_CALL_ERR_ALREADY_ACCEPT = 4,
        INVITATION_API_CALL_ERR_ALREADY_SENT = 5
    }
    export enum JoinChannelError {
        JOIN_CHANNEL_ERR_FAILURE = 1,
        JOIN_CHANNEL_ERR_REJECTED = 2,
        JOIN_CHANNEL_ERR_INVALID_ARGUMENT = 3,
        JOIN_CHANNEL_TIMEOUT = 4,
        JOIN_CHANNEL_ERR_EXCEED_LIMIT = 5,
        JOIN_CHANNEL_ERR_ALREADY_JOINED = 6,
        JOIN_CHANNEL_ERR_TOO_OFTEN = 7,
        JOIN_CHANNEL_ERR_JOIN_SAME_CHANNEL_TOO_OFTEN = 8,
        JOIN_CHANNEL_ERR_USER_NOT_LOGGED_IN = 102,
        JOIN_CHANNEL_ERR_ABORTED_BY_LEAVE = 210,
        JOIN_CHANNEL_ERR_ALREADY_JOINED_CHANNEL_OF_SAME_ID = 211
    }
    export enum LeaveChannelError {
        LEAVE_CHANNEL_ERR_FAILURE = 1,
        LEAVE_CHANNEL_ERR_REJECTED = 2,
        LEAVE_CHANNEL_ERR_NOT_IN_CHANNEL = 3,
        LEAVE_CHANNEL_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum LoginError {
        LOGIN_ERR_UNKNOWN = 1,
        LOGIN_ERR_REJECTED = 2,
        LOGIN_ERR_INVALID_ARGUMENT = 3,
        LOGIN_ERR_INVALID_APP_ID = 4,
        LOGIN_ERR_INVALID_TOKEN = 5,
        LOGIN_ERR_TOKEN_EXPIRED = 6,
        LOGIN_ERR_NOT_AUTHORIZED = 7,
        LOGIN_ERR_ALREADY_LOGIN = 8,
        LOGIN_ERR_TIMEOUT = 9,
        LOGIN_ERR_TOO_OFTEN = 10,
        LOGIN_ERR_ABORTED_BY_LOGOUT = 11
    }
    export enum LogoutError {
        LOGOUT_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum PeerMessageError {
        PEER_MESSAGE_ERR_FAILURE = 1,
        PEER_MESSAGE_ERR_TIMEOUT = 2,
        PEER_MESSAGE_ERR_TOO_OFTEN = 5,
        PEER_MESSAGE_ERR_INVALID_USERID = 6,
        PEER_MESSAGE_ERR_INVALID_MESSAGE = 7,
        PEER_MESSAGE_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum PeerSubscriptionStatusError {
        PEER_SUBSCRIPTION_STATUS_ERR_FAILURE = 1,
        PEER_SUBSCRIPTION_STATUS_ERR_INVALID_ARGUMENT = 2,
        PEER_SUBSCRIPTION_STATUS_ERR_REJECTED = 3,
        PEER_SUBSCRIPTION_STATUS_ERR_TIMEOUT = 4,
        PEER_SUBSCRIPTION_STATUS_ERR_TOO_OFTEN = 5,
        PEER_SUBSCRIPTION_STATUS_ERR_OVERFLOW = 6,
        PEER_SUBSCRIPTION_STATUS_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum QueryPeersBySubscriptionOptionError {
        QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_FAILURE = 1,
        QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TIMEOUT = 2,
        QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TOO_OFTEN = 3,
        QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum QueryPeersOnlineStatusError {
        QUERY_PEERS_ONLINE_STATUS_ERR_INVALID_ARGUMENT = 0,
        QUERY_PEERS_ONLINE_STATUS_ERR_REJECTED = 1,
        QUERY_PEERS_ONLINE_STATUS_ERR_TIMEOUT = 2,
        QUERY_PEERS_ONLINE_STATUS_ERR_TOO_OFTEN = 3,
        QUERY_PEERS_ONLINE_STATUS_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum RenewTokenError {
        RENEW_TOKEN_ERR_FAILURE = 1,
        RENEW_TOKEN_ERR_INVALID_ARGUMENT = 2,
        RENEW_TOKEN_ERR_REJECTED = 3,
        RENEW_TOKEN_ERR_TOO_OFTEN = 4,
        RENEW_TOKEN_ERR_TOKEN_EXPIRED = 5,
        RENEW_TOKEN_ERR_INVALID_TOKEN = 6,
        RENEW_TOKEN_ERR_USER_NOT_LOGGED_IN = 102,
        RENEW_TOKEN_ERR_ABORTED_BY_LOGOUT = 201
    }
}

export declare namespace RtmEvents {
    export interface LocalInvitationEvents {
        LocalInvitationAccepted(response: string): () => {};
        LocalInvitationCanceled(): () => {};
        LocalInvitationFailure(reason: RtmStatusCode.LocalInvitationFailureReason): () => {};
        LocalInvitationReceivedByPeer(): () => {};
        LocalInvitationRefused(response: string): () => {};
    }
    export interface RemoteInvitationEvents {
        RemoteInvitationAccepted(): void;
        RemoteInvitationCanceled(content: string): void;
        RemoteInvitationFailure(reason: RtmStatusCode.RemoteInvitationFailureReason): void;
        RemoteInvitationRefused(): void;
    }
    export interface RtmChannelEvents {
        AttributesUpdated(attributes: ChannelAttributes): void;
        ChannelMessage(message: RtmMessage, memberId: string, messagePros: ReceivedMessageProperties): void;
        MemberCountUpdated(memberCount: number): void;
        MemberJoined(memberId: string): void;
        MemberLeft(memberId: string): void;
    }
    export interface RtmClientEvents {
        ConnectionStateChanged(newState: RtmStatusCode.ConnectionState, reason: RtmStatusCode.ConnectionChangeReason): void;
        MessageFromPeer(message: RtmMessage, peerId: string, messageProps: ReceivedMessageProperties): void;
        PeersOnlineStatusChanged(status: PeersOnlineStatusMap): void;
        RemoteInvitationReceived(remoteInvitation: RemoteInvitation): void;
        TokenExpired(): void;
    }
}

export declare type RtmMessage = RtmTextMessage;

export declare interface RtmParameters {
    logFilter?: LogFilterType_2;
    confPriCloudAddr?: {
        ServerAdd: string;
        Port?: number;
        Wss?: boolean;
    };
    ConfPriCloudAddr?: {
        ServerAdd: string;
        Port?: number;
        Wss?: boolean;
    };
}

export declare namespace RtmStatusCode {
    export enum ConnectionChangeReason {
        BANNED_BY_SERVER = "BANNED_BY_SERVER",
        INTERRUPTED = "INTERRUPTED",
        LOGIN = "LOGIN",
        LOGIN_FAILURE = "LOGIN_FAILURE",
        LOGIN_SUCCESS = "LOGIN_SUCCESS",
        LOGIN_TIMEOUT = "LOGIN_TIMEOUT",
        LOGOUT = "LOGOUT",
        REMOTE_LOGIN = "REMOTE_LOGIN"
    }
    export enum ConnectionState {
        ABORTED = "ABORTED",
        CONNECTED = "CONNECTED",
        CONNECTING = "CONNECTING",
        DISCONNECTED = "DISCONNECTED",
        RECONNECTING = "RECONNECTING"
    }
    export enum LocalInvitationFailureReason {
        INVITATION_EXPIRE = "INVITATION_EXPIRE",
        NOT_LOGGEDIN = "NOT_LOGGEDIN",
        PEER_NO_RESPONSE = "PEER_NO_RESPONSE",
        PEER_OFFLINE = "PEER_OFFLINE"
    }
    export enum LocalInvitationState {
        ACCEPTED_BY_REMOTE = "ACCEPTED_BY_REMOTE",
        CANCELED = "CANCELED",
        FAILURE = "FAILURE",
        IDLE = "IDLE",
        RECEIVED_BY_REMOTE = "RECEIVED_BY_REMOTE",
        REFUSED_BY_REMOTE = "REFUSED_BY_REMOTE",
        SENT_TO_REMOTE = "SENT_TO_REMOTE"
    }
    export enum MessageType {
        RAW = "RAW",
        TEXT = "TEXT"
    }
    export enum PeerOnlineState {
        OFFLINE = "OFFLINE",
        ONLINE = "ONLINE",
        UNREACHABLE = "UNREACHABLE"
    }
    export enum PeerSubscriptionOption {
        ONLINE_STATUS = "ONLINE_STATUS"
    }
    export enum RemoteInvitationFailureReason {
        ACCEPT_FAILURE = "ACCEPT_FAILURE",
        INVITATION_EXPIRE = "INVITATION_EXPIRE",
        PEER_OFFLINE = "PEER_OFFLINE"
    }
    export enum RemoteInvitationState {
        ACCEPTED = "ACCEPTED",
        ACCEPT_SENT_TO_LOCAL = "ACCEPT_SENT_TO_LOCAL",
        CANCELED = "CANCELED",
        FAILURE = "FAILURE",
        INVITATION_RECEIVED = "INVITATION_RECEIVED",
        REFUSED = "REFUSED"
    }
}

export declare interface RtmTextMessage {
    description?: undefined;
    messageType?: undefined | "TEXT";
    text: string;
}

export declare interface SendMessageOptions {
    enableHistoricalMessaging?: undefined | false | true;
    enableOfflineMessaging?: undefined | false | true;
}

export { }
