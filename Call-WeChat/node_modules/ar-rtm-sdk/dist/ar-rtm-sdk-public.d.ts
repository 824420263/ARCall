/**
 * ArRTM 是 RTM SDK 的导出模块。
 *
 * 使用 `<script>` 标签引入 SDK 时，产生名为 ArRTM 的全局变量，该变量含有该模块的所有成员。
 *
 * @example
 * 直接在 HTML 中引入 `<script src="ar-rtm-sdk-0.9.1.js"></script>`。
 *
 * **Note:**
 * 此处文件名 ar-rtm-sdk-0.9.1.js 中的版本号 0.9.1 仅供参考，安装时请使用最新版的 SDK 和链接地址。
 */
declare namespace ArRTM {
    /**
     * RTM SDK 的编译信息
     */
    const BUILD: string;
    /* Excluded from this release type: ConnectionChangeReason */
    /* Excluded from this release type: ConnectionState */
    /* Excluded from this release type: END_CALL_PREFIX */
    /**
     * 输出 ERROR 级别的日志信息。
     */
    const LOG_FILTER_ERROR: LogFilterType;
    /**
     * 输出 ERROR、WARNING 和 INFO 级别的日志信息。 我们推荐你将日志级别设为该等级。
     */
    const LOG_FILTER_INFO: LogFilterType;
    /**
     * 不输出日志信息。
     */
    const LOG_FILTER_OFF: LogFilterType;
    /**
     * 输出 ERROR 和 WARNING 级别的日志信息。
     */
    const LOG_FILTER_WARNING: LogFilterType;
    /* Excluded from this release type: LocalInvitationState */
    /* Excluded from this release type: MessageType */
    /* Excluded from this release type: PeerOnlineState */
    /* Excluded from this release type: PeerSubscriptionOption */
    /* Excluded from this release type: RemoteInvitationFailureReason */
    /* Excluded from this release type: LocalInvitationFailureReason */
    /* Excluded from this release type: RemoteInvitationState */
    /**
     * RTM SDK 的版本号。
     */
    const VERSION: string;
    /**
     * 该方法创建并返回一个 [[RtmClient]] 对象实例。
     * RTM SDK 支持多个 [[RtmClient]] 实例。
     * [[RtmClient]] 类的所有接口函数都是异步调用。
     * @example **创建 RtmClient 对象，同时开启日志上传，关闭浏览器 Console 日志。**
     * ```
     * import ArRTM from 'ar-rtm-sdk';
     * const client = ArRTM.createInstance('demoAppId', { enableLogUpload: true, logFilter: ArRTM.LOG_FILTER_OFF }); // Pass your App ID and RtmParameters.
     * ```
     *
     * @param {string} appId  传入项目的 App ID。ASCII 字符，字符串长度为 32 可见字符。
     * @param {RtmParameters} [params]  对象的配置参数。
     * @returns {RtmClient}
     * 一个 [[RtmClient]] 对象实例。
     */
    function createInstance(appId: string, params?: RtmParameters): RtmClient;
}
export { ArRTM }
export default ArRTM;

/**
 *
 *
 * @interface AttributesMap
 */
export declare interface AttributesMap {
    [key: string]: string;
}

/**
 *
 *
 * @interface ChannelAttributeOptions
 */
export declare interface ChannelAttributeOptions {
    /**
     * 是否通知所有频道成员本次频道属性变更。该标志位仅对本次 API 调用有效：
     * - `true`: 通知所有频道成员本次频道属性变更。
     * - `false`: (默认) 不通知所有频道成员本次频道属性变更。
     *
     * @type {(undefined | false | true)}
     */
    enableNotificationToChannelMembers?: undefined | false | true;
}

/**
 *
 *
 * @interface ChannelAttributeProperties
 */
export declare interface ChannelAttributeProperties {
    /**
     * 频道属性最近一次更新的时间戳（毫秒）。
     *
     * @type {number}
     */
    lastUpdateTs: number;
    /**
     * 最近一次更新频道属性用户的 ID。
     *
     * @type {string}
     */
    lastUpdateUserId: string;
    /**
     * 频道属性的属性值。长度不得超过 8 KB。
     *
     * @type {string}
     */
    value: string;
}

/**
 *
 *
 * @interface ChannelAttributes
 */
export declare interface ChannelAttributes {
    [key: string]: ChannelAttributeProperties;
}

/**
 *
 *
 * @interface ChannelMemberCountResult
 */
export declare interface ChannelMemberCountResult {
    [channelId: string]: number;
}

/**
 *
 *
 * @class EventEmitter
 */
declare class EventEmitter<T extends EventMap> {
    private _events;
    constructor();
    /**
     * Gets all the listeners of a specified event.
     *
     * @param {string} eventName
     * @returns
     */
    /**
     * Listens for a specified event.
     *
     * When the event happens, the callback that you pass is triggered.
     *
     * @event
     * @param {string} eventName
     * @param {Function} callback The callback to be triggered.
     */
    on<K extends keyof T>(eventName: K, callback: T[K]): void;
    /**
     *
     *
     * @param {string} eventName
     * @param {Function} callback
     */
    once<K extends keyof T>(eventName: K, callback: T[K]): void;
    /**
     *
     *
     * @param {string} eventName
     * @param {Function} callback
     */
    off<K extends keyof T>(eventName: K, callback: T[K]): void;
    /**
     *
     *
     * @param {string} [eventName]
     */
    removeAllListeners<K extends keyof T>(eventName?: K): void;
    /**
     *
     *
     * @param {string} eventName
     */
    emit<K extends keyof T>(eventName: K, ...args: any[]): void;
    /**
     *
     *
     * @param {any[]} evtList
     * @param {Function} callback
     * @returns
     */
    private _indexOfListener;
}

/**
 *
 * 参考
 * https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type
 * https://rjzaworski.com/2019/10/event-emitters-in-typescript
 * https://stackoverflow.com/questions/39142858/declaring-events-in-a-typescript-class-which-extends-eventemitter
 * https://gist.github.com/rsms/3744301784eb3af8ed80bc746bef5eeb#file-eventlistener-d-ts
 */
declare type EventMap = Record<string, any>;

declare interface ILocalInvitation {
    /**
     * 被叫的 uid
     * @type {string}
     */
    readonly calleeId: string;
    /**
     * 主叫设置的呼叫邀请内容。
     *
     * @type {string}
     */
    content: string;
    /**
     * 被叫设置的响应内容。
     *
     * @type {string}
     */
    readonly response: string;
    /**
     *
     *
     * @type {LocalInvitationState}
     * @readonly
     */
    state: keyof typeof RtmStatusCode.LocalInvitationState;
    /**
     * 取消已发送的呼叫邀请。该方法无异步回调。如需监听 LocalInvitationState 变化，请通过 on 方法注册 LocalInvitationEvents 中的事件回调。
     *
     */
    cancel(): void;
    /**
     * 向指定用户（被叫）发送呼叫邀请。该方法无异步回调。如需监听 LocalInvitationState 变化，请通过 on 方法注册 LocalInvitationEvents 中的事件回调。
     *
     */
    send(): void;
}

declare interface IRemoteInvitation {
    /**
     * 主叫的 uid。
     * @type {string}
     */
    readonly callerId: string;
    /**
     * 主叫设置的呼叫邀请内容。
     *
     * @type {string}
     */
    content: string;
    /**
     * 被叫设置的响应内容。
     *
     * @type {string} 最大长度为 8 KB。
     */
    response: string;
    /**
     *
     *
     * @type {LocalInvitationState}
     * @readonly
     */
    state: keyof typeof RtmStatusCode.RemoteInvitationState;
    /**
     * 接受来自主叫的呼叫邀请。
     *
     */
    accept(): void;
    /**
     * 拒绝来自主叫的呼叫邀请。
     *
     */
    refuse(): void;
}

declare interface IRtmChannel {
    getMembers(): Promise<string[]>;
    join(): Promise<void>;
    leave(): Promise<void>;
    sendMessage(message: RtmMessage, messageOptions?: SendMessageOptions): Promise<void>;
}

declare interface IRtmClient {
    addOrUpdateChannelAttributes(channelId: string, attributes: AttributesMap, options?: ChannelAttributeOptions): Promise<void>;
    addOrUpdateLocalUserAttributes(attributes: AttributesMap): Promise<void>;
    clearChannelAttributes(channelId: string, options?: ChannelAttributeOptions): Promise<void>;
    clearLocalUserAttributes(): Promise<void>;
    createChannel(channelId: string): RtmChannel;
    createLocalInvitation(calleeId: string): LocalInvitation;
    deleteChannelAttributesByKeys(channelId: string, attributeKeys: string[], options?: ChannelAttributeOptions): Promise<void>;
    deleteLocalUserAttributesByKeys(attributeKeys: string[]): Promise<void>;
    getChannelAttributes(channelId: string): Promise<ChannelAttributes>;
    getChannelAttributesByKeys(channelId: string, keys: string[]): Promise<ChannelAttributes>;
    getChannelMemberCount(channelIds: string[]): Promise<ChannelMemberCountResult>;
    getUserAttributes(userId: string): Promise<AttributesMap>;
    getUserAttributesByKeys(userId: string, attributeKeys: string[]): Promise<AttributesMap>;
    login(options: {
        token?: undefined | string;
        uid: string;
    }): Promise<void>;
    logout(): Promise<void>;
    queryPeersBySubscriptionOption(option: RtmStatusCode.PeerSubscriptionOption): Promise<string[]>;
    queryPeersOnlineStatus(peerIds: string[]): Promise<PeersOnlineStatusResult>;
    renewToken(token: string): Promise<void>;
    sendMessageToPeer(message: RtmMessage, peerId: string, options?: SendMessageOptions): Promise<PeerMessageSendResult>;
    setChannelAttributes(channelId: string, attributes: AttributesMap, options?: ChannelAttributeOptions): Promise<void>;
    setLocalUserAttributes(attributes: AttributesMap): Promise<void>;
    setParameters(params: RtmParameters): void;
    subscribePeersOnlineStatus(peerIds: string[]): Promise<void>;
    unsubscribePeersOnlineStatus(peerIds: string[]): Promise<void>;
}

/**
 * LocalInvitation 对象实例上的事件类型。
 *
 * @class LocalInvitation
 * @extends {EventEmitter<RtmEvents.LocalInvitationEvents>}
 */
export declare class LocalInvitation extends EventEmitter<RtmEvents.LocalInvitationEvents> implements ILocalInvitation {
    /* Excluded from this release type: _callId */
    /**
     * 被叫的 uid
     * @type {string}
     */
    readonly calleeId: string;
    /* Excluded from this release type: client */
    /**
     * 主叫设置的呼叫邀请内容。
     *
     * @type {string}
     */
    content: string;
    /**
     *
     *
     * @type {LocalInvitationState}
     * @readonly
     */
    state: keyof typeof RtmStatusCode.LocalInvitationState;
    /**
     * 被叫设置的响应内容。
     *
     * @type {string}
     */
    readonly response: string;
    /**
     * Creates an instance of LocalInvitation.
     * @hidden
     */
    constructor(client: any, callId: string, calleeId: string);
    /**
     * 取消已发送的呼叫邀请。该方法无异步回调。如需监听 LocalInvitationState 变化，请通过 on 方法注册 LocalInvitationEvents 中的事件回调。
     *
     */
    cancel(): void;
    /**
     * 向指定用户（被叫）发送呼叫邀请。该方法无异步回调。如需监听 LocalInvitationState 变化，请通过 on 方法注册 LocalInvitationEvents 中的事件回调。
     *
     */
    send(): void;
}

declare type LogFilterType = LogLevel;

/**
 *
 * @ignore
 * @enum {number}
 */
declare enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARNING = 2,
    ERROR = 3,
    NONE = 4
}

/**
 *
 *
 * @interface PeerMessageSendResult
 */
export declare interface PeerMessageSendResult {
    /**
     * 该布尔值属性代表消息接收方是否已收到发出的消息。
     * - `true`: 点对点消息投递成功，对方已收到；
     * - `false`: 对方不在线，未收到该消息。
     * @type {boolean}
     */
    hasPeerReceived: boolean;
}

/**
 *
 *
 * @interface PeersOnlineStatusMap
 */
export declare interface PeersOnlineStatusMap {
    [peerId: string]: RtmStatusCode.PeerOnlineState;
}

/**
 * 用户／在线状态键值对。
 * - `true`: 用户已登录到 RTM 系统。
 * - `false`: 用户已登出 RTM 系统或因其他原因与 RTM 系统断开连接。
 * @interface PeersOnlineStatusResult
 */
export declare interface PeersOnlineStatusResult {
    /**
     * 用户／在线状态键值对。
     * - `true`: 用户已登录到 RTM 系统。
     * - `false`: 用户已登出 RTM 系统或因其他原因与 RTM 系统断开连接。
     */
    [peerId: string]: boolean;
}

/**
 *
 * @interface ReceivedMessageProperties
 */
export declare interface ReceivedMessageProperties {
    /**
     *
     *
     * @type {boolean}
     */
    /**
     * 供消息接收者检查消息是否在服务端被保存过（仅适用于点对点消息）。
     * > Note
     * 如果消息没有被消息服务器保存过，该方法将返回 NO。也就是说：只有当消息发送者将 enableOfflineMessaging 设为 true，发送离线消息且在发送离线消息时对端不在线，对端重新上线后调用该方法会返回 `true` 。
     * - `true`: 被保存过（消息服务器保存了该条消息且在对端重新上线后重新发送成功）。
     * - `false`: 未被保存过。
     * @type {boolean}
     */
    isOfflineMessage: boolean;
    /**
     * 消息服务器接收到消息的时间戳（毫秒）。
     * > Note
     * - 你不能设置时间戳，但是你可以从该时间戳推断出消息的大致发送时间。
     * - 时间戳的精度为毫秒。仅用于展示，不建议用于消息的严格排序。
     * @type {boolean}
     */
    serverReceivedTs: number;
}

/**
 * RemoteInvitation 对象实例上的事件类型。
 *
 * @class RemoteInvitation
 * @extends {EventEmitter<RtmEvents.RemoteInvitationEvents>}
 */
export declare class RemoteInvitation extends EventEmitter<RtmEvents.RemoteInvitationEvents> implements IRemoteInvitation {
    /* Excluded from this release type: client */
    /* Excluded from this release type: _callId */
    /**
     * 主叫的 uid。
     *
     * @type {string}
     */
    readonly callerId: string;
    /**
     * 主叫设置的呼叫邀请内容。
     *
     * @type {string} 最大长度为 8 KB。
     */
    readonly content: string;
    /**
     * 被叫设置的响应内容。
     *
     * @type {string} 最大长度为 8 KB。
     */
    response: string;
    /**
     * 呼叫邀请的状态。详见： RemoteInvitationState 。
     *
     * @type {RemoteInvitationState}
     * @readonly
     */
    state: keyof typeof RtmStatusCode.RemoteInvitationState;
    private _timer?;
    /**
     * Creates an instance of RemoteInvitation.
     * @param {string} callId
     * @param {string} callerId
     * @param {string} content
     * @ignore
     */
    constructor(callId: string, callerId: string, content: string);
    /**
     * 接受来自主叫的呼叫邀请。该方法无异步回调。如需监听 RemoteInvitationState 变化，请通过 on 方法注册 RemoteInvitationEvents 中的事件回调。
     *
     */
    accept(): void;
    /**
     * 拒绝来自主叫的呼叫邀请。该方法无异步回调。如需监听 RemoteInvitationState 变化，请通过 on 方法注册 RemoteInvitationEvents 中的事件回调。
     *
     */
    refuse(): void;
}

/**
 * RTM 频道实例
 *
 * @class RtmChannel
 * @extends {EventEmitter<RtmEvents.RtmChannelEvents>}
 * @implements {IRtmChannel}
 */
export declare class RtmChannel extends EventEmitter<RtmEvents.RtmChannelEvents> implements IRtmChannel {
    /* Excluded from this release type: client */
    /* Excluded from this release type: memberCount */
    /* Excluded from this release type: attributes */
    /**
     * 获取该频道实例的 ID。
     *
     * @type {string}
     */
    channelId: string;
    /* Excluded from this release type: bindChannelEvents */
    /**
     * Creates an instance of RtmChannel.
     * @param {*} client
     * @param {string} channelId
     * @ignore
     */
    constructor(client: any, channelId: string);
    /**
     * 获取频道用户列表
     *
     * @returns {Promise<string[]>}
     * 该 Promise 会在成功获取频道用户列表后 resolve。Promise 返回的值为该频道所有用户 ID 的数组。
     */
    getMembers(): Promise<string[]>;
    /**
     * 调用该方法加入该频道，加入频道成功后可收到该频道消息和频道用户进退通知。
     * 你最多可以加入 20 个频道。
     *
     * @returns {Promise<void>}
     * 该 Promise 会在加入频道成功后 resolve。
     */
    join(): Promise<void>;
    /**
     * 调用该方法离开该频道，不再接收频道消息和频道用户进退通知。
     *
     * @returns {Promise<void>}
     * 该 Promise 会在离开频道成功后 resolve。
     */
    leave(): Promise<void>;
    /**
     * 发送频道消息，所有加入频道的用户都会收到该频道消息。
     * 发送消息（包括点对点消息和频道消息）的频率上限为 60 qps。
     * example 发送频道消息。
     * ```
     * channel.sendMessage({ text: 'test channel message' }).then(() => {
     *  // 你的代码：频道消息发送成功处理逻辑。
     *  }).catch(error) => {
     *  // 你的代码：频道消息发送失败处理逻辑。
     *  })
     * ```
     *
     * @param {RtmMessage} message  要发送的消息对象。
     * @param {SendMessageOptions} [messageOptions]
     * @returns {Promise<void>}
     * 该 Promise 会在发送频道消息成功后 resolve。
     */
    sendMessage(message: RtmMessage, messageOptions?: SendMessageOptions): Promise<void>;
    /* Excluded from this release type: _handleChannelEvents */
}

/**
 * RTM 客户端实例
 *
 * @class RtmClient
 * @extends {EventEmitter}
 */
export declare class RtmClient extends EventEmitter<RtmEvents.RtmClientEvents> implements IRtmClient {
    /* Excluded from this release type: _appId */
    /* Excluded from this release type: _gateway */
    /* Excluded from this release type: _rtmServer */
    /* Excluded from this release type: _useWss */
    /* Excluded from this release type: _sid */
    /* Excluded from this release type: _userAttributes */
    /* Excluded from this release type: _localCall */
    /* Excluded from this release type: _remoteCall */
    /* Excluded from this release type: _sessionId */
    /* Excluded from this release type: _joinStartTime */
    /** future holding client initiated connection attempt */
    private connectFuture?;
    /** future holding sdk initiated reconnection attempt */
    private reconnectFuture?;
    uid: string;
    token: string | null;
    channels: {
        [channelId: string]: {
            joined: boolean;
            channel: RtmChannel;
        };
    };
    channelAttributesCacheLru: {
        [channelId: string]: AttributesMap;
    };
    /**
     * Creates an instance of RtmClient.
     * @param {string} appid
     * @ignore
     */
    constructor(appid: string, options?: RtmParameters);
    /**
     * 添加或更新某指定频道的属性。
     * - 如果属性已存在，该方法更新该频道的已有属性；
     * - 如果属性不存在，该方法增加该频道的属性。
     *
     * **Note**
     * - 你无需加入指定频道即可为该频道更新频道属性。
     * - 当某频道处于空频道状态（无人状态）数分钟后，该频道的频道属性将被清空。
     * - [[setLocalUserAttributes]] 、 [[addOrUpdateChannelAttributes]] 、 [[deleteChannelAttributesByKeys]] ，和 [[clearChannelAttributes]] 一并计算在内：调用频率限制为每 5 秒 10 次。
     * @param {string} channelId  该指定频道的 ID。
     * @param {AttributesMap} attributes   待增加或更新的属性列表。
     * @param {ChannelAttributeOptions} [options] 频道属性操作选项。详见 ChannelAttributeOptions 。
     */
    addOrUpdateChannelAttributes(channelId: string, attributes: AttributesMap, options?: ChannelAttributeOptions): Promise<void>;
    /**
     * 添加或更新本地用户的属性。
     * - 如果属性已存在，该方法更新本地用户的已有属性；
     * - 如果属性不存在，该方法增加本地用户的属性。
     *
     * @param {AttributesMap} attributes 待增加或更新的属性列表。
     * 该 Promise 会在添加或更新本地用户属性成功后 resolve。
     */
    addOrUpdateLocalUserAttributes(attributes: AttributesMap): Promise<void>;
    /**
     * 清空某指定频道的属性。
     * **Note**
     * - 你无需加入指定频道即可清空该频道的属性。
     * - RtmClient.setChannelAttributes() 、 addOrUpdateChannelAttributes 、 deleteChannelAttributesByKeys ，和 clearChannelAttributes 一并计算在内：调用频率限制为每 5 秒 10 次。
     *
     * @param {string} channelId  该指定频道的频道 ID。
     * @param {ChannelAttributeOptions} [options] 频道属性操作选项。详见 ChannelAttributeOptions 。
     * @returns {Promise<void>}
     */
    clearChannelAttributes(channelId: string, options?: ChannelAttributeOptions): Promise<void>;
    /**
     *
     *
     * @returns {Promise<void>}
     */
    clearLocalUserAttributes(): Promise<void>;
    /**
     * 该方法创建一个 [[RtmChannel]] 对象实例。
     *
     * @param {string} channelId
     * 频道名称。该字符串不可超过 64 字节。以下为支持的字符集范围:
     * - 26 个小写英文字母 a-z
     * - 26 个大写英文字母 A-Z
     * - 10 个数字 0-9
     * - 空格
     * - "!", "#", "$", "%", "&", "(", ")", "+", "-", ":", ";", "<", "=", ".", ">", "?", "@", "[", "]", "^", "_", " {", "}", "|", "~", ","
     * **Note**
     * 请不要将 channelId 设为空、null，或字符串 "null"。
     * @returns {RtmChannel}
     * 一个 RtmChannel 对象实例。
     */
    createChannel(channelId: string): RtmChannel;
    /**
     * 该方法创建一个 LocalInvitation 对象实例。
     *
     * @param {string} calleeId 被叫的 uid。
     * @returns {LocalInvitation}
     * 一个 [[LocalInvitation]] 对象实例。
     */
    createLocalInvitation(calleeId: string): LocalInvitation;
    /**
     * 上传一个文件到 anyrtc 服务器以获取 RtmFileMessage 实例，可用于发送文件消息。
     *
     * @example
     * ```
     * // 从文件获得的 blob 对象
     * const blob = <Blob>
     * // 上传文件获得一个 RtmFileMessage 实例
     * const mediaMessage = await client.createMediaMessageByUploading(blob)
     * // 发送点对点文件消息
     * await client.sendMessageToPeer(mediaMessage, <peerId>)
     * ```
     * @param payload 上传文件的内容。大小不能超过 32 MB。
     * @param params 包括上传文件的文件名、文件消息的描述、缩略图以及消息类型。
     *
     * fileName string
     * 上传文件的文件名。fileName, description 和 thumbnail 的总大小不能超过 32 KB。
     *
     * description string
     * 文件消息的描述。fileName, description 和 thumbnail 的总大小不能超过 32 KB。
     * thumbnail undefined | Blob
     * 上传文件的缩略图。fileName, description 和 thumbnail 的总大小不能超过 32 KB。
     * messageType ''FILE''
     * 消息类型。''FILE'' 表示文件消息。
     * @param transHandler 一个 MediaTransferHandler 实例。可以用来取消上传或报告上传进度。
     */
    /**
     * 创建一个消息实例，可用于发送点对点消息或频道消息。对于文件消息和图片消息，如果对应的文件或图片已经上传且 media ID 仍然有效，你无需再次上传文件或图片，可以直接调用此方法获取消息实例用来发送点对点消息或频道消息。
     * @param message
     */
    /**
     * 删除某指定频道的指定属性。
     * **Note**
     * 你无需加入指定频道即可删除该频道的属性。
     * 当某频道处于空频道状态（无人状态）数分钟后，该频道的频道属性将被清空。setLocalUserAttributes 、 addOrUpdateChannelAttributes 、 deleteChannelAttributesByKeys ，和 clearChannelAttributes 一并计算在内：调用频率限制为每 5 秒 10 次。
     * @param {string} channelId  该指定频道的 ID。
     * @param {string[]} attributeKeys  属性名列表。
     * @param {ChannelAttributeOptions} [options] 频道属性操作选项。详见 ChannelAttributeOptions 。
     * @returns {Promise<void>}
     */
    deleteChannelAttributesByKeys(channelId: string, attributeKeys: string[], options?: ChannelAttributeOptions): Promise<void>;
    /**
     * 删除本地用户的指定属性。
     *
     * @param {string[]} attributeKeys  属性名列表。
     * @returns {Promise<void>}
     * 该 Promise 会在删除指定属性成功后 resolve。
     */
    deleteLocalUserAttributesByKeys(attributeKeys: string[]): Promise<void>;
    /**
     * 查询某指定频道的全部属性。
     * **Note**
     * - 你无需加入指定频道即可查询该频道的属性。
     * - getChannelAttributes 和 getChannelAttributesByKeys 一并计算在内：调用频率限制为每 5 秒 10 次。
     *
     * @param {string} channelId  该指定频道的 ID。
     * @returns {Promise<ChannelAttributes>}
     */
    getChannelAttributes(channelId: string): Promise<ChannelAttributes>;
    /**
     * 查询某指定频道指定属性名的属性。
     * **Note**
     * - 你无需加入指定频道即可查询该频道的属性。
     * - [[getChannelAttributes]] 和 [[getChannelAttributesByKeys]] 一并计算在内：调用频率限制为每 5 秒 10 次。
     * @param {string} channelId  该指定频道的频道 ID。
     * @param {string[]} keys 频道属性名列表。
     * @returns {Promise<ChannelAttributes>}
     */
    getChannelAttributesByKeys(channelId: string, keys: string[]): Promise<ChannelAttributes>;
    /**
     * 查询单个或多个频道的成员人数。
     * **Note**
     * - 该方法的调用频率上限为每秒 1 次。
     * - 不支持一次查询超过 32 个频道的成员人数。
     * @param {string[]} channelIds 指定频道名列表。
     * @returns {Promise<ChannelMemberCountResult>}
     */
    getChannelMemberCount(channelIds: string[]): Promise<ChannelMemberCountResult>;
    /**
     * 获取指定用户的全部属性。
     *
     * @param {string} userId 指定用户的用户 ID。
     * @returns {Promise<AttributesMap>}
     */
    getUserAttributes(userId: string): Promise<AttributesMap>;
    /**
     * 获取指定用户指定属性名的属性。
     *
     * @param {string} userId 指定用户的用户 ID。
     * @param {string[]} attributeKeys  属性名列表。
     * @returns {Promise<AttributesMap>}
     */
    getUserAttributesByKeys(userId: string, attributeKeys: string[]): Promise<AttributesMap>;
    /**
     * 登录
     *
     * @param {({ token?: undefined | string, uid: string })} options
     * @typeParam token  可选的动态密钥，一般由客户的服务端获取。
     * @typeParam uid  登录 RTM 系统的用户 ID。该字符串不可超过 64 字节。以下为支持的字符集范围:
     * - 26 个小写英文字母 a-z
     * - 26 个大写英文字母 A-Z
     * - 10 个数字 0-9
     * - 空格
     * - "!", "#", "$", "%", "&", "(", ")", "+", "-", ":", ";", "<", "=", ".", ">", "?", "@", "[", "]", "^", "_", " {", "}", "|", "~", ","
     * **Note**
     * - 请不要将 uid 设为空、null，或字符串 "null"。
     * - uid 不支持 number 类型。建议调用 toString() 方法转化非 string 型 uid。
     * @returns {Promise<void>} 该 Promise 会在登录成功后 resolve。
     */
    login(options: {
        token?: undefined | string;
        uid: string;
    }): Promise<void>;
    private clearConnectionFutures;
    /**
     * 退出登录，退出后自动断开连接和销毁回调监听。
     *
     * @returns {Promise<void>} 该 Promise 会在登出成功并断开 WebSocket 连接后 resolve。
     */
    logout(): Promise<void>;
    /**
     * 获取某特定内容被订阅的用户列表。
     *
     * @param {PeerSubscriptionOption} option 被订阅的类型。详见 RtmStatusCode.PeerSubscriptionOption 。
     * @returns {Promise<string[]>}
     */
    queryPeersBySubscriptionOption(option: RtmStatusCode.PeerSubscriptionOption): Promise<string[]>;
    /**
     * 查询指定用户的在线状态。
     *
     * @param {string[]} peerIds  用户 ID 列表。
     * @returns {Promise<PeersOnlineStatusResult>}
     */
    queryPeersOnlineStatus(peerIds: string[]): Promise<PeersOnlineStatusResult>;
    /**
     * 更新当前 Token。
     *
     * @param {string} token  新的 Token。
     * @returns {Promise<void>}
     */
    renewToken(token: string): Promise<void>;
    /**
     * 本地用户（发送者）向指定用户（接收者）发送点对点消息或点对点的离线消息。
     * 发送消息（包括点对点消息和频道消息）的频率上限为 60 qps。
     * ```
     * client.sendMessageToPeer(
     *  { text: 'test peer message' }, // 一个 RtmMessage 对象。
     *  'PeerId', // 对端用户的 uid。
     * ).then(sendResult => {
     *  if (sendResult.hasPeerReceived) {
     *    // 你的代码：远端用户收到消息事件。
     *  } else {
     *    // 你的代码：服务器已收到消息，对端未收到消息。
     *  }
     * }).catch(error => {
     *  // 你的代码：点对点消息发送失败。
     * });
     * ```
     *
     * @param {RtmMessage} message  要发送的文字消息。
     * @param {string} peerId 远端用户的 uid。
     * @param {SendMessageOptions} [options]  开启离线消息。详见 SendMessageOptions。
     * **Note**
     * uid 不支持 number 类型。建议调用 toString() 方法转化非 string 型 uid。
     * @returns {Promise<PeerMessageSendResult>}
     * 该 Promise 会在发送成功后 resolve。resolve 的值代表对方是否在线并接收成功。
     */
    sendMessageToPeer(message: RtmMessage, peerId: string, options?: SendMessageOptions): Promise<PeerMessageSendResult>;
    /**
     * 全量设置某指定频道的属性。
     * **Note**
     * - 你无需加入指定频道即可为该频道设置频道属性。
     * - 当某频道处于空频道状态（无人状态）数分钟后，该频道的频道属性将被清空。
     * - [[setLocalUserAttributes]] 、 [[addOrUpdateChannelAttributes]] 、 [[deleteChannelAttributesByKeys]] ，和 [[clearChannelAttributes]] 一并计算在内：调用频率限制为每 5 秒 10 次。
     *
     * @param {string} channelId  该指定频道的频道 ID。
     * @param {AttributesMap} attributes  频道属性列表对象。
     * @param {ChannelAttributeOptions} [options] 频道属性操作选项。详见 [[ChannelAttributeOptions]] 。
     * @returns {Promise<void>}
     */
    setChannelAttributes(channelId: string, attributes: AttributesMap, options?: ChannelAttributeOptions): Promise<void>;
    /**
     * 全量设置本地用户的属性。
     *
     * @param {AttributesMap} attributes  新的属性。
     * @returns {Promise<void>}
     * 该 Promise 会在设置本地用户属性成功后 resolve。
     */
    setLocalUserAttributes(attributes: AttributesMap): Promise<void>;
    /**
     * 配置 SDK 提供技术预览或特别定制功能。
     *
     * @param {RtmParameters} params  详见 [[RtmParameters。]]
     */
    setParameters(params: RtmParameters): void;
    /**
     * 订阅指定单个或多个用户的在线状态。
     * - 首次订阅成功后，SDK 会通过 RtmClientEvents.PeersOnlineStatusChanged 回调返回被订阅用户在线状态。
     * - 每当被订阅用户在线状态发生变化时，SDK 都会通过 RtmClientEvents.PeersOnlineStatusChanged 回调通知订阅方。
     * - 如果 SDK 在断线重连过程中有被订阅用户的在线状态发生改变，SDK 会在重连成功时通过 RtmClientEvents.PeersOnlineStatusChanged 回调通知订阅方。
     * **Note**
     * 用户登出 RTM 系统后，所有之前的订阅内容都会被清空；重新登录后，如需保留之前订阅内容则需重新订阅。
     * SDK 会在网络连接中断时进入断线重连状态。重连成功时 SDK 会自动重新订阅之前订阅用户，无需人为干预。
     * @param {string[]} peerIds  被制定用户的用户 ID。
     * @returns {Promise<void>}
     */
    subscribePeersOnlineStatus(peerIds: string[]): Promise<void>;
    /**
     * 退订指定单个或多个用户的在线状态。
     *
     * @param {string[]} peerIds  被退订用户的用户 ID 阵列。
     * @returns {Promise<void>}
     */
    unsubscribePeersOnlineStatus(peerIds: string[]): Promise<void>;
    /* Excluded from this release type: _emitConnectionState */
    /* Excluded from this release type: _createRtmServerInstance */
    /* Excluded from this release type: _authGateWay */
    /* Excluded from this release type: _connectRtmServer */
}

export declare namespace RtmErrorCode {
    export enum BasicErrorCode {
        INVALID_OPERATION = 1
    }
    export enum AttributeOperationError {
        /**
         * 通用错误码。属性操作失败。
         */
        ATTRIBUTE_OPERATION_ERR_FAILURE = 2,
        /**
         * 无效的输入参数。比如，你不可以把用户属性或频道属性设为 ""。
         */
        ATTRIBUTE_OPERATION_ERR_INVALID_ARGUMENT = 3,
        /**
         * 4: 本次操作后，用户属性或频道属性超过上限。
         * - 用户属性操作：在本次属性操作后，用户属性总大小超过 16 KB 长度限制，或单条用户属性超过 8 KB 长度限制，或用户属性个数超过 32 个的条目上限。
         * - 频道属性操作：在本次属性操作后，频道属性总大小超过 32 KB 长度限制，或单条频道属性超过 8 KB 长度限制，或频道属性个数超过 32 个的条目上限。
         */
        ATTRIBUTE_OPERATION_ERR_SIZE_OVERFLOW = 4,
        /**
         * 5: 方法调用频率超过限制。
         * - setLocalUserAttributes、addOrUpdateLocalUserAttributes、deleteLocalUserAttributesByKeys，和 clearLocalUserAttributes 一并计算在内：调用频率限制为每 5 秒 10 次。
         * - getUserAttributes 和 getUserAttributesByKeys 一并计算在内：调用频率限制为每 5 秒 40 次。
         * - setChannelAttributes、addOrUpdateChannelAttributes、deleteChannelAttributesByKeys，和 clearChannelAttributes 一并计算在内：调用频率限制为每 5 秒 10 次。
         * - getChannelAttributes 和 getChannelAttributesByKeys 一并计算在内：调用频率限制为每 5 秒 10 次。
         */
        ATTRIBUTE_OPERATION_ERR_TOO_OFTEN = 5,
        /**
         * 未找到指定用户。该用户或者处于离线状态或者并不存在。
         */
        ATTRIBUTE_OPERATION_ERR_USER_NOT_FOUND = 6,
        /**
         * 属性操作超时。当前的超时设定为 5 秒。可能原因：用户正处于 ABORTED 状态或 RECONNECTING 状态。
         */
        ATTRIBUTE_OPERATION_ERR_TIMEOUT = 7,
        /**
         * 执行属性相关操作前未调用 login 方法或者 login 方法调用未成功。
         */
        ATTRIBUTE_OPERATION_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum ChannelMessageError {
        /**
         * 通用错误。发送频道消息失败。
         */
        CHANNEL_MESSAGE_ERR_FAILURE = 1,
        /**
         * 服务器未收到频道消息或者 SDK 未在 10 秒内收到服务器响应。当前的超时设置为 10 秒。可能原因：用户正处于 ABORTED 状态或 RECONNECTING 状态。
         */
        CHANNEL_MESSAGE_ERR_TIMEOUT = 2,
        /**
         * 发送消息（点对点消息和频道消息一并计算在内）超过 60 次／秒的上限。
         */
        CHANNEL_MESSAGE_ERR_TOO_OFTEN = 3,
        /**
         * 消息为 null 或超出 32 KB 的长度限制。
         */
        CHANNEL_MESSAGE_ERR_INVALID_MESSAGE = 4,
        /**
         * 用户不在频道内。
         */
        CHANNEL_MESSAGE_ERR_NOT_IN_CHANNEL = 5,
        /**
         * 发送频道消息前未调用 login 方法或者 login 方法调用未成功。
         */
        CHANNEL_MESSAGE_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum CreateChannelError {
        /**
         * 输入参数无效。
         */
        CREATE_CHANNEL_ERR_INVALID_ARGUMENT = 1
    }
    export enum CreateInstanceError {
        /**
         * 输入参数无效。
         */
        CREATE_INSTANCE_ERR_INVALID_ARGUMENT = 1
    }
    export enum GetChannelMemberCountErrCode {
        /**
         * 1: 通用未知错误。
         */
        GET_CHANNEL_MEMBER_COUNT_ERR_FAILURE = 1,
        /**
         * 2: 输入的频道 ID 无效。
         */
        GET_CHANNEL_MEMBER_COUNT_ERR_INVALID_ARGUMENT = 2,
        /**
         * 3: 方法调用过于频繁。超过 1 次每秒的限制。
         */
        GET_CHANNEL_MEMBER_COUNT_ERR_TOO_OFTEN = 3,
        /**
         * 4: 服务器响应超时。当前的当前的超时设定为 5 秒。
         */
        GET_CHANNEL_MEMBER_COUNT_ERR_TIMEOUT = 4,
        /**
         * 5: 指定频道数大于 32。
         */
        GET_CHANNEL_MEMBER_COUNT_ERR_EXCEED_LIMIT = 5,
        /**
         * 101: RTM 服务未完成初始化。
         */
        GET_CHANNEL_MEMBER_COUNT_ERR_NOT_INITIALIZED = 101,
        /**
         * 102: 本次操作前未调用 login 方法或者 login 方法调用未成功。
         */
        GET_CHANNEL_MEMBER_COUNT_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum GetMembersError {
        /**
         * 通用错误。获取频道成员列表失败。
         */
        GET_MEMBERS_ERR_FAILURE = 1,
        /**
         * 预留错误码
         */
        GET_MEMBERS_ERR_REJECTED = 2,
        /**
         * 获取频道成员列表超时。目前的超时设置为 5 秒。可能原因：用户正处于 ABORTED 状态或 RECONNECTING 状态。
         */
        GET_MEMBERS_ERR_TIMEOUT = 3,
        /**
         * 方法调用频率超过 5 次每 2 秒的上限。
         */
        GET_MEMBERS_ERR_TOO_OFTEN = 4,
        /**
         * 用户不在频道内。
         */
        GET_MEMBERS_ERR_NOT_IN_CHANNEL = 5,
        /**
         * 获取频道成员列表前未调用 login 方法或者 login 方法调用未成功。
         */
        GET_MEMBERS_ERR_USER_NOT_LOGGED_IN = 6
    }
    export enum InvitationApiCallError {
        /**
         * 呼叫邀请相关 API 调用失败：参数无效。
         */
        INVITATION_API_CALL_ERR_INVALID_ARGUMENT = 1,
        /**
         * 呼叫邀请相关 API 调用失败：呼叫邀请未开始。
         */
        INVITATION_API_CALL_ERR_NOT_STARTED = 2,
        /**
         * 呼叫邀请相关 API 调用结果：呼叫邀请已结束。
         */
        INVITATION_API_CALL_ERR_ALREADY_END = 3,
        /**
         * 呼叫邀请相关 API 调用结果：已接受邀请。
         */
        INVITATION_API_CALL_ERR_ALREADY_ACCEPT = 4,
        /**
         * 呼叫邀请相关 API 调用结果：呼叫邀请已发送。
         */
        INVITATION_API_CALL_ERR_ALREADY_SENT = 5
    }
    export enum JoinChannelError {
        /**
         * 通用错误。用户加入频道失败。
         */
        JOIN_CHANNEL_ERR_FAILURE = 1,
        /**
         * 预留错误码
         */
        JOIN_CHANNEL_ERR_REJECTED = 2,
        /**
         * 用户加入频道失败。输入参数无效。
         */
        JOIN_CHANNEL_ERR_INVALID_ARGUMENT = 3,
        /**
         * 用户加入频道超时。目前的超时设置为 5 秒。可能原因：用户正处于 ABORTED 状态或 RECONNECTING 状态。
         */
        JOIN_CHANNEL_TIMEOUT = 4,
        /**
         * 同时加入的频道数超过 20 上限。
         */
        JOIN_CHANNEL_ERR_EXCEED_LIMIT = 5,
        /**
         * 用户正在加入频道或已成功加入频道。
         */
        JOIN_CHANNEL_ERR_ALREADY_JOINED = 6,
        /**
         * 方法调用超过 50 次每 3 秒的上限。
         */
        JOIN_CHANNEL_ERR_TOO_OFTEN = 7,
        /**
         * 8: 加入相同频道的频率超过每 5 秒 2 次的上限。
         */
        JOIN_CHANNEL_ERR_JOIN_SAME_CHANNEL_TOO_OFTEN = 8,
        /**
         * 用户加入频道前未调用 login 方法或者 login 方法调用未成功。
         */
        JOIN_CHANNEL_ERR_USER_NOT_LOGGED_IN = 102,
        JOIN_CHANNEL_ERR_ABORTED_BY_LEAVE = 210,
        JOIN_CHANNEL_ERR_ALREADY_JOINED_CHANNEL_OF_SAME_ID = 211
    }
    export enum LeaveChannelError {
        /**
         * 通用错误。用户离开频道失败。
         */
        LEAVE_CHANNEL_ERR_FAILURE = 1,
        /**
         * 预留错误码
         */
        LEAVE_CHANNEL_ERR_REJECTED = 2,
        /**
         * 用户已不在频道内。
         */
        LEAVE_CHANNEL_ERR_NOT_IN_CHANNEL = 3,
        /**
         * 用户用户在调用 leave 方法前未调用 \ref anyrtc::rtm::IRtmService::login "login" 方法或者 \ref anyrtc::rtm::IRtmService::login "login" 方法调用未成功。
         */
        LEAVE_CHANNEL_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum LoginError {
        /**
         * 通用登录错误。
         */
        LOGIN_ERR_UNKNOWN = 1,
        /**
         * 无效的登录参数。
         */
        LOGIN_ERR_INVALID_ARGUMENT = 2,
        /**
         * 无效的 App ID。
         */
        LOGIN_ERR_INVALID_APP_ID = 3,
        /**
         * 无效的 Token。
         */
        LOGIN_ERR_INVALID_TOKEN = 4,
        /**
         * Token 已过期，登录被拒绝。
         */
        LOGIN_ERR_TOKEN_EXPIRED = 5,
        /**
         * 预留错误码
         */
        LOGIN_ERR_NOT_AUTHORIZED = 6,
        /**
         * 用户已登录，或已正在登录 RTM 系统，或未调用 logout 方法退出 ABORTED 状态。
         */
        LOGIN_ERR_ALREADY_LOGIN = 7,
        /**
         * 登录超时。目前的超时设置为 6 秒。
         */
        LOGIN_ERR_TIMEOUT = 8,
        /**
         * 登录过于频繁。超过 2 次／秒的上限。
         */
        LOGIN_ERR_TOO_OFTEN = 9,
        /**
         * 网关错误
         */
        LOGIN_ERR_ABORTED_BY_LOGOUT = 10,
        /**
         * 网关错误
         */
        LOGIN_ERR_GATEWAY_CONNECT_FAILED = 11
    }
    export enum LogoutError {
        /**
         * 登出 RTM 系统前未调用 login 方法或者 login 方法调用未成功。
         */
        LOGOUT_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum PeerMessageError {
        /**
         * 发送点对点消息失败。
         */
        PEER_MESSAGE_ERR_FAILURE = 1,
        /**
         * 发送点对点消息超时。当前的超时时间设置为 10 秒。可能原因：用户正处于 ABORTED 状态或 RECONNECTING 状态。
         */
        PEER_MESSAGE_ERR_TIMEOUT = 2,
        /**
         * 发送消息（点对点消息和频道消息一并计算在内）超过 60 次／秒的上限。
         */
        PEER_MESSAGE_ERR_TOO_OFTEN = 5,
        /**
         * 用户 ID 无效。
         */
        PEER_MESSAGE_ERR_INVALID_USERID = 6,
        /**
         * 消息为 null 或超出 32 KB 的长度限制。
         */
        PEER_MESSAGE_ERR_INVALID_MESSAGE = 7,
        /**
         * 发送点对点消息前未调用 login 方法或者 login 方法调用未成功。
         */
        PEER_MESSAGE_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum PeerSubscriptionStatusError {
        /**
         * 通用错误。订阅或退订操作失败。
         */
        PEER_SUBSCRIPTION_STATUS_ERR_FAILURE = 1,
        /**
         * 无效的输入参数。
         */
        PEER_SUBSCRIPTION_STATUS_ERR_INVALID_ARGUMENT = 2,
        /**
         * 预留错误码
         */
        PEER_SUBSCRIPTION_STATUS_ERR_REJECTED = 3,
        /**
         * 服务器响应超时。当前的超时设置为 10 秒。可能原因：用户正处于 ABORTED 状态或 RECONNECTING 状态。
         */
        PEER_SUBSCRIPTION_STATUS_ERR_TIMEOUT = 4,
        /**
         * 方法调用过于频繁。超过 10 次每 5 秒的限制。
         */
        PEER_SUBSCRIPTION_STATUS_ERR_TOO_OFTEN = 5,
        /**
         * 订阅人数超过 512 人的上限。
         */
        PEER_SUBSCRIPTION_STATUS_ERR_OVERFLOW = 6,
        /**
         * 订阅或退订操作前未调用 login 方法或者 login 方法调用未成功。
         */
        PEER_SUBSCRIPTION_STATUS_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum QueryPeersBySubscriptionOptionError {
        /**
         * 通用错误。根据订阅类型获取被订阅用户列表失败。
         */
        QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_FAILURE = 1,
        /**
         * 服务器响应超时。当前的超时设置为 5 秒。可能原因：用户正处于 ABORTED 状态或 RECONNECTING 状态。
         */
        QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TIMEOUT = 2,
        /**
         * 方法调用过于频繁。超过 10 次每 5 秒的限制。
         */
        QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TOO_OFTEN = 3,
        /**
         * 根据订阅类型获取被订阅用户列表前未调用 login 方法或者 login 方法调用未成功。
         */
        QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum QueryPeersOnlineStatusError {
        /**
         * 无效的输入参数。
         */
        QUERY_PEERS_ONLINE_STATUS_ERR_INVALID_ARGUMENT = 0,
        /**
         * 预留错误码
         */
        QUERY_PEERS_ONLINE_STATUS_ERR_REJECTED = 1,
        /**
         * 服务器响应超时。当前的超时设置为 10 秒。可能原因：用户正处于 ABORTED 状态或 RECONNECTING 状态。
         */
        QUERY_PEERS_ONLINE_STATUS_ERR_TIMEOUT = 2,
        /**
         * 方法调用过于频繁。超过 10 次每 5 秒的限制。
         */
        QUERY_PEERS_ONLINE_STATUS_ERR_TOO_OFTEN = 3,
        /**
         * 查询指定用户在线状态前未调用 login 方法或者 login 方法调用未成功。
         */
        QUERY_PEERS_ONLINE_STATUS_ERR_USER_NOT_LOGGED_IN = 102
    }
    export enum RenewTokenError {
        /**
         * 通用错误。更新 Token 失败。
         */
        RENEW_TOKEN_ERR_FAILURE = 1,
        /**
         * 无效的输入参数。
         */
        RENEW_TOKEN_ERR_INVALID_ARGUMENT = 2,
        /**
         * 预留错误码
         */
        RENEW_TOKEN_ERR_REJECTED = 3,
        /**
         * 方法调用过于频繁。超过 2 次／秒的上限。
         */
        RENEW_TOKEN_ERR_TOO_OFTEN = 4,
        /**
         * 输入 Token 已过期。
         */
        RENEW_TOKEN_ERR_TOKEN_EXPIRED = 5,
        /**
         * 输入 Token 无效。
         */
        RENEW_TOKEN_ERR_INVALID_TOKEN = 6,
        /**
         * 更新 Token 前未调用 login 方法或者 login 方法调用未成功。
         */
        RENEW_TOKEN_ERR_USER_NOT_LOGGED_IN = 102,
        RENEW_TOKEN_ERR_ABORTED_BY_LOGOUT = 201
    }
}

export declare namespace RtmEvents {
    /**
     * 主叫收到的事件回调
     *
     * @interface LocalInvitationEvents
     */
    export interface LocalInvitationEvents {
        /**
         * 返回给主叫：被叫已接受呼叫邀请。
         *
         * @param {string} response 被叫设置的响应内容。
         */
        LocalInvitationAccepted(response: string): void;
        /**
         * 返回给主叫：呼叫邀请已被成功取消。
         *
         */
        LocalInvitationCanceled(): void;
        /**
         * 返回给主叫：呼叫邀请进程失败。
         *
         * @param {LocalInvitationFailureReason} reason 呼叫邀请的失败原因。详见： LocalInvitationFailureReason 。
         */
        LocalInvitationFailure(reason: RtmStatusCode.LocalInvitationFailureReason): void;
        /**
         * 返回给主叫：被叫已收到呼叫邀请。
         *
         */
        LocalInvitationReceivedByPeer(): void;
        /**
         * 返回给主叫：被叫已拒绝呼叫邀请。
         *
         * @param {string} response 被叫设置的响应内容。
         */
        LocalInvitationRefused(response: string): void;
    }
    /**
     * 被叫收到的事件回调
     *
     * @interface RemoteInvitationEvents
     */
    export interface RemoteInvitationEvents {
        /**
         * 返回给被叫：接受呼叫邀请成功。
         *
         */
        RemoteInvitationAccepted(): void;
        /**
         * 返回给被叫：主叫已取消呼叫邀请。
         *
         * @param {string} content
         */
        RemoteInvitationCanceled(content: string): void;
        /**
         * 返回给被叫：呼叫邀请进程失败。
         *
         * @param {RemoteInvitationFailureReason} reason 呼叫邀请失败原因。详见： [RemoteInvitationFailureReason] 。
         */
        RemoteInvitationFailure(reason: RtmStatusCode.RemoteInvitationFailureReason): void;
        /**
         * 返回给被叫：拒绝呼叫邀请成功。
         *
         */
        RemoteInvitationRefused(): void;
    }
    /**
     * RTM 频道收到的事件回调
     *
     * @interface RtmChannelEvents
     */
    export interface RtmChannelEvents {
        /**
         * 频道属性更新回调。返回所在频道的所有属性。
         *
         * @note
         * 只有当频道属性更新者将 enableNotificationToChannelMembers 设为 `true` 后，该回调才会被触发。请注意：该标志位仅对当前频道属性操作有效。
         *
         * @param {ChannelAttributes} attributes 自定义频道属性
         */
        AttributesUpdated(attributes: ChannelAttributes): void;
        /**
         * 收到频道消息的事件通知。
         *
         * @param {RtmMessage} message 接收到的频道消息对象。
         * @param {string} memberId 该频道消息的发送者 uid。
         * @param {ReceivedMessageProperties} messagePros 接收到的消息的属性。
         */
        ChannelMessage(message: RtmMessage, memberId: string, messagePros: ReceivedMessageProperties): void;
        /**
         * 频道成员人数更新回调。返回最新频道成员人数。
         *
         * - 频道成员人数 ≤ 512 时，最高触发频率为每秒 1 次。
         * - 频道成员人数超过 512 时，最高触发频率为每 3 秒 1 次。
         * - 用户在成功加入频道时会收到该回调。你可以通过监听该回调获取加入频道时的频道成员人数和后继人数更新。
         * @param {number} memberCount 最新频道成员人数。
         */
        MemberCountUpdated(memberCount: number): void;
        /**
         * 收到用户加入频道的通知。
         *
         * @note
         * 当频道成员超过 512 时，该回调失效。
         * @param {string} memberId
         */
        MemberJoined(memberId: string): void;
        /**
         * 收到用户离开频道的通知。
         * 当频道成员超过 512 时，该回调失效。
         *
         * @param {string} memberId 离开频道的远端用户的 uid。
         */
        MemberLeft(memberId: string): void;
    }
    /**
     * RTM 客户端收到的事件回调
     *
     * @interface RtmClientEvents
     */
    export interface RtmClientEvents {
        /**
         * 通知 SDK 与 RTM 系统的连接状态发生了改变。
         *
         * @param {RtmStatusCode.ConnectionState} newState 当前网络状态
         * @param {RtmStatusCode.ConnectionChangeReason} reason 发生当前网络状态的原因
         */
        ConnectionStateChanged(newState: RtmStatusCode.ConnectionState, reason: RtmStatusCode.ConnectionChangeReason): void;
        /**
         * 收到来自对端的点对点消息。
         *
         * @param {RtmMessage} message 远端用户发送的消息对象
         * @param {string} peerId 远端用户的 ID
         * @param {ReceivedMessageProperties} messageProps 接收到的消息的属性。
         */
        MessageFromPeer(message: RtmMessage, peerId: string, messageProps: ReceivedMessageProperties): void;
        /**
         * 被订阅用户在线状态改变回调。
         *
         * 首次订阅在线状态成功时，SDK 也会返回本回调，显示所有被订阅用户的在线状态。
         * 每当被订阅用户的在线状态发生改变，SDK 都会通过该回调通知订阅方。
         * 如果 SDK 在断线重连过程中有被订阅用户的在线状态发生改变，SDK 会在重连成功时通过该回调通知订阅方。
         *
         * @param {PeersOnlineStatusMap} status
         */
        PeersOnlineStatusChanged(status: PeersOnlineStatusMap): void;
        /**
         * 收到来自主叫的呼叫邀请。
         *
         * @param {RemoteInvitation} remoteInvitation
         */
        RemoteInvitationReceived(remoteInvitation: RemoteInvitation): void;
        /**
         * Token 即将过期
         *
         * 收到该回调，应该立即调用 [[RtmClient.renewToken]] 方法来更新 Token
         */
        TokenWillExpired(): void;
        /**
         * Token 已经过期
         *
         * 收到该回调，应该退出重新登录
         */
        TokenDidExpired(): void;
    }
}

/**
 * 用于表示 RTM 消息的类型别名。RtmMessage 可以是文本消息 RtmTextMessage ，自定义二进制消息 RtmRawMessage ，图片消息 RtmImageMessage，或文件消息 RtmFileMessage。
 */
export declare type RtmMessage = RtmTextMessage;

/**
 *
 *
 * @interface RtmParameters
 */
export declare interface RtmParameters {
    /**
     * 设置是否上传日志。默认关闭。
     * - true: 启用日志上传；
     * - false: （默认）关闭日志上传。
     * @type {(undefined | false | true)}
     */
    /**
     * 设置日志输出等级。
     * 设置 SDK 的输出日志输出等级。不同的输出等级可以单独或组合使用。日志级别顺序依次为 OFF、ERROR、WARNING 和 INFO。
     * 选择一个级别，你就可以看到在该级别之前所有级别的日志信息。例如，你选择 WARNING 级别，就可以看到在 ERROR 和 WARNING 级别上的所有日志信息。
     * - ArRTM.LOG_FILTER_OFF
     * - ArRTM.LOG_FILTER_ERROR
     * - ArRTM.LOG_FILTER_INFO （默认）
     * - ArRTM.LOG_FILTER_WARNING
     * @type {LogFilterType}
     */
    logFilter?: LogFilterType;
    /**
     * 配置私有云地址
     *
     * @type {{
             *     ServerAdd: string,
             *     Port?: number,
             *     Wss?: boolean
             *   }}
     */
    confPriCloudAddr?: {
        ServerAdd: string;
        Port?: number;
        Wss?: boolean;
    };
    /**
     * 配置私有云地址
     *
     * @type {{
             *     ServerAdd: string,
             *     Port?: number,
             *     Wss?: boolean
             *   }}
     */
    ConfPriCloudAddr?: {
        ServerAdd: string;
        Port?: number;
        Wss?: boolean;
    };
}

export declare namespace RtmStatusCode {
    /**
     * 连接状态改变原因
     */
    export enum ConnectionChangeReason {
        /**
         * SDK 被服务器禁止登录 RTM 系统。
         */
        BANNED_BY_SERVER = "BANNED_BY_SERVER",
        /**
         * SDK 与 RTM 系统的连接被中断超过 4 秒。
         */
        INTERRUPTED = "INTERRUPTED",
        LOGIN = "LOGIN",
        /**
         * SDK 登录 RTM 系统失败。
         */
        LOGIN_FAILURE = "LOGIN_FAILURE",
        /**
         * SDK 登录 RTM 系统成功
         */
        LOGIN_SUCCESS = "LOGIN_SUCCESS",
        /**
         * SDK 无法登录 RTM 系统超过 6 秒，停止登录。
         */
        LOGIN_TIMEOUT = "LOGIN_TIMEOUT",
        /**
         * SDK 已登出 RTM 系统。
         */
        LOGOUT = "LOGOUT",
        /**
         * 另一个用户正以相同的 uid 登陆 RTM 系统。
         */
        REMOTE_LOGIN = "REMOTE_LOGIN"
    }
    /**
     * SDK 与 RTM 系统的连接状态类型
     *
     * @enum {number}
     */
    export enum ConnectionState {
        /**
         * SDK 停止登录 RTM 系统。
         * 原因可能为：
         * - 另一实例已经以同一用户 ID 登录 RTM 系统。
         * - token 已过期。
         * 请在调用方法 logout 后，调用方法 login 登录 RTM 系统。
         */
        ABORTED = "ABORTED",
        /**
         * SDK 已登录 RTM 系统。
         */
        CONNECTED = "CONNECTED",
        CONNECTING = "CONNECTING",
        DISCONNECTED = "DISCONNECTED",
        RECONNECTING = "RECONNECTING"
    }
    /**
     * 发起 LocalInvitation 失败的原因
     *
     * @enum {number}
     */
    export enum LocalInvitationFailureReason {
        /**
         * **返回给主叫**。如果被叫已在主叫发出呼叫邀请 30 秒内通过 ACK 响应确认收到呼叫邀请，
         * 但主叫和被叫均未对呼叫邀请采取任何操作（取消、接受、拒绝），则呼叫邀请在发送 60 秒后过期。
         */
        INVITATION_EXPIRE = "INVITATION_EXPIRE",
        /**
         * 返回给主叫。主叫未登录。
         */
        NOT_LOGGEDIN = "NOT_LOGGEDIN",
        /**
         * **返回给主叫**。被叫在线，但主叫发出呼叫邀请 30 秒后仍未收到被叫的 ACK 响应确认收到呼叫邀请。一般由于网络中断造成。
         */
        PEER_NO_RESPONSE = "PEER_NO_RESPONSE",
        /**
         * **返回给主叫**。被叫不在线。
         * SDK 会在被叫不在线时不断重发呼叫邀请。若消息发送 30 秒后被叫仍未上线，SDK 会返回此错误原因。
         */
        PEER_OFFLINE = "PEER_OFFLINE"
    }
    /**
     * 发起 LocalInvitation 的状态码
     *
     * @enum {number}
     */
    export enum LocalInvitationState {
        /**
         * 返回给主叫的呼叫邀请状态码：被叫已接受呼叫邀请。
         */
        ACCEPTED_BY_REMOTE = "ACCEPTED_BY_REMOTE",
        /**
         * 返回给主叫的呼叫邀请状态码：已成功取消呼叫邀请。
         */
        CANCELED = "CANCELED",
        /**
         * 返回给主叫的呼叫邀请状态码：呼叫邀请发送失败。
         */
        FAILURE = "FAILURE",
        /**
         * 返回给主叫的呼叫邀请状态码：初始状态。
         */
        IDLE = "IDLE",
        /**
         * 返回给主叫的呼叫邀请状态码：被叫已收到呼叫邀请。
         */
        RECEIVED_BY_REMOTE = "RECEIVED_BY_REMOTE",
        /**
         * 返回给主叫的呼叫邀请状态码：被叫已拒绝呼叫邀请。
         */
        REFUSED_BY_REMOTE = "REFUSED_BY_REMOTE",
        /**
         * 仅供内部使用
         */
        SENT_TO_REMOTE = "SENT_TO_REMOTE"
    }
    /**
     * 消息类型
     *
     * @enum {number}
     */
    export enum MessageType {
        /**
         * 文本消息。
         */
        TEXT = "TEXT"
    }
    /**
     * 用户在线状态
     *
     * @enum {number}
     */
    export enum PeerOnlineState {
        /**
         * 2: 用户不在线（用户未登录或已登出 RTM 系统，或服务器连续 30 秒未收到来自 SDK 的数据包）。
         */
        OFFLINE = "OFFLINE",
        /**
         * 0: 用户在线。
         */
        ONLINE = "ONLINE",
        /**
         * 1: 连接状态不稳定（服务器连续 6 秒未收到来自 SDK 的数据包）。
         */
        UNREACHABLE = "UNREACHABLE"
    }
    /**
     * 订阅用户的配置项
     *
     * @enum {number}
     */
    export enum PeerSubscriptionOption {
        /**
         * 订阅指定用户的在线状态。
         */
        ONLINE_STATUS = "ONLINE_STATUS"
    }
    /**
     * 收到远程呼叫邀请 RemoteInvitation 失败的原因
     *
     * @enum {number}
     */
    export enum RemoteInvitationFailureReason {
        /**
         * 返回给被叫。被叫接受呼叫邀请后未收到主叫的 ACK 响应，则呼叫邀请在被叫接受呼叫邀请 5 秒后超时。一般由于网络中断造成。
         */
        ACCEPT_FAILURE = "ACCEPT_FAILURE",
        /**
         * 返回给被叫。如果被叫已在主叫发出呼叫邀请 30 秒内通过 ACK 响应确认收到呼叫邀请，但主叫和被叫均未对呼叫邀请采取任何操作（取消、接受、拒绝），则呼叫邀请在发送 60 秒后过期。
         */
        INVITATION_EXPIRE = "INVITATION_EXPIRE",
        /**
         * 返回给被叫。主叫不在线，呼叫邀请失败。
         */
        PEER_OFFLINE = "PEER_OFFLINE"
    }
    /**
     * 收到远程呼叫邀请 RemoteInvitation 的状态
     *
     * @enum {number}
     */
    export enum RemoteInvitationState {
        /**
         * 返回给被叫的呼叫邀请状态码：已接受来自主叫的呼叫邀请。
         */
        ACCEPTED = "ACCEPTED",
        /**
         * 仅供内部使用。
         */
        ACCEPT_SENT_TO_LOCAL = "ACCEPT_SENT_TO_LOCAL",
        /**
         * 返回给被叫的呼叫邀请状态码：主叫已取消呼叫邀请。
         */
        CANCELED = "CANCELED",
        /**
         * 返回给被叫的呼叫邀请状态码：来自主叫的呼叫邀请发送失败。
         */
        FAILURE = "FAILURE",
        /**
         * 返回给被叫的呼叫邀请状态码：收到了来自主叫的呼叫邀请。
         */
        INVITATION_RECEIVED = "INVITATION_RECEIVED",
        /**
         * 返回给被叫的呼叫邀请状态码：已拒绝来自主叫的呼叫邀请。
         */
        REFUSED = "REFUSED"
    }
}

export declare interface RtmTextMessage {
    /**
     * 文本消息的文字描述。最大长度为 32 KB。
     * *Note*
     * 文本消息和文字描述的总大小不能超过 32 KB。
     * @type {undefined}
     */
    description?: undefined;
    /**
     * 消息类型。TEXT 代表文本消息。
     *
     * @type {(undefined | "TEXT")}
     */
    messageType?: undefined | "TEXT";
    /**
     * 文本消息的内容。最大长度为 32 KB。
     * *Note*
     * 文本消息和文字描述的总大小不能超过 32 KB。
     * @type {string}
     */
    text: string;
}

export declare interface SendMessageOptions {
    /**
     * PRIVATE BETA 是否保存为历史消息。
     * - `true`: 将该消息保存为历史消息。
     * - `false`: （默认）不将该消息保存为历史消息。
     * @type {(undefined | false | true)}
     */
    enableHistoricalMessaging?: undefined | false | true;
    /**
     * 是否设置为离线消息（仅适用于点对点消息）。
     * - `true`: 将该消息设为离线消息。
     * - `false`: （默认）不将该消息设为离线消息。
     * @type {(undefined | false | true)}
     */
    enableOfflineMessaging?: undefined | false | true;
}

export { }
